<#
{
    "Category": 3,
    "Name": "Out of Stock",
    "Info": "Auto-rejects out-of-stock items during Fill. [Next shipping day at 12 PM] [Use on Fill screen]",
    "Shortcut": "F1",
    "Code": "112",
    "Window": "Minimized",
    "Programs": "java.exe"
}
#>

# Set the working directory to the script's location
$scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
Set-Location -Path $scriptDir

# Load variables from precheck.ps1
. .\precheck.ps1

# Check the exit code of the last command
if ($LASTEXITCODE -ne 0) {
    . .\errorHandler.ps1 $global:precheckError
    exit 1
}

# List of variables to check
$variables = @{
    "Main" = $Main
    "Clavier" = $Clavier
    "Cap2Txt" = $Cap2Txt
    "SendKeys" = $SendKeys
    "Printer" = $Printer
}

# Check if all necessary variables are defined
foreach ($var in $variables.GetEnumerator()) {
    if (-not $var.Value) {
        $errorMessage = "Error: '$($var.Key)' is not defined.`nOpen Setup [Shift + F1]"
        . ./errorHandler.ps1 $errorMessage
        exit 1
    }
}

$ErrorActionPreference = "Stop"
add-type -AssemblyName microsoft.VisualBasic
add-type -AssemblyName System.Windows.Forms
[Microsoft.VisualBasic.Interaction]::AppActivate("Enterprise")
[System.Windows.Forms.SendKeys]::SendWait("%{j}")
start-sleep -Milliseconds 450

if (-not ([Microsoft.VisualBasic.Interaction]::AppActivate("Fill"))) {

    & $Clavier /sendkeys "[{Focus,0,Fill *}][Enter][Tab]"

    # -------------------------
    # Holiday and scheduling logic (year-agnostic, includes observed dates)
    # Holidays included:
    # - New Year's Day (Jan 1) - observed
    # - Presidents Day (third Monday in Feb)
    # - Memorial Day (last Monday in May)
    # - Independence Day (July 4) - observed
    # - Labor Day (first Monday in Sep)
    # - Thanksgiving (fourth Thursday in Nov)
    # - Christmas Day (Dec 25) - observed
    # -------------------------

    function Get-NthWeekdayOfMonth {
        param(
            [int]$Year,
            [int]$Month,
            [System.DayOfWeek]$Weekday,
            [int]$N
        )
        $firstOfMonth = Get-Date -Year $Year -Month $Month -Day 1
        $offset = ([int]$Weekday - [int]$firstOfMonth.DayOfWeek + 7) % 7
        return $firstOfMonth.AddDays($offset + 7*($N-1)).Date
    }

    function Get-LastWeekdayOfMonth {
        param(
            [int]$Year,
            [int]$Month,
            [System.DayOfWeek]$Weekday
        )
        $lastOfMonth = (Get-Date -Year $Year -Month $Month -Day 1).AddMonths(1).AddDays(-1)
        $offset = ([int]$lastOfMonth.DayOfWeek - [int]$Weekday + 7) % 7
        return $lastOfMonth.AddDays(-$offset).Date
    }

    function Get-ObservedDate {
        param([datetime]$DateToObserve)
        switch ($DateToObserve.DayOfWeek) {
            'Saturday' { return $DateToObserve.AddDays(-1).Date }  # observed Friday
            'Sunday'   { return $DateToObserve.AddDays(1).Date }   # observed Monday
            default    { return $DateToObserve.Date }
        }
    }

    function Get-HolidaysForYear {
        param([int]$Year)
        $holidays = @()

        # New Year's Day (Jan 1) - actual and observed
        $ny = Get-Date -Year $Year -Month 1 -Day 1
        $holidays += $ny.Date
        $holidays += Get-ObservedDate -DateToObserve $ny

        # Presidents Day (third Monday in February)
        $presidents = Get-NthWeekdayOfMonth -Year $Year -Month 2 -Weekday ([DayOfWeek]::Monday) -N 3
        $holidays += $presidents

        # Memorial Day (last Monday in May)
        $memorial = Get-LastWeekdayOfMonth -Year $Year -Month 5 -Weekday ([DayOfWeek]::Monday)
        $holidays += $memorial

        # Independence Day (July 4) - actual and observed
        $july4 = Get-Date -Year $Year -Month 7 -Day 4
        $holidays += $july4.Date
        $holidays += Get-ObservedDate -DateToObserve $july4

        # Labor Day (first Monday in September)
        $labor = Get-NthWeekdayOfMonth -Year $Year -Month 9 -Weekday ([DayOfWeek]::Monday) -N 1
        $holidays += $labor

        # Thanksgiving (fourth Thursday in November)
        $thanksgiving = Get-NthWeekdayOfMonth -Year $Year -Month 11 -Weekday ([DayOfWeek]::Thursday) -N 4
        $holidays += $thanksgiving

        # Christmas (Dec 25) - actual and observed
        $xmas = Get-Date -Year $Year -Month 12 -Day 25
        $holidays += $xmas.Date
        $holidays += Get-ObservedDate -DateToObserve $xmas

        # Return unique dates
        return ($holidays | Sort-Object -Unique)
    }

    function Is-Holiday {
        param([datetime]$CheckDate)
        # Force integer year to avoid arithmetic errors
        $yearInt = [int]$CheckDate.Year

        # Compute adjacent years in separate variables to avoid ambiguous operator overloads
        $prevYear = $yearInt - 1
        $nextYear = $yearInt + 1
        $yearsToCheck = @($prevYear, $yearInt, $nextYear)

        foreach ($y in $yearsToCheck) {
            $hols = Get-HolidaysForYear -Year $y
            if ($hols -contains $CheckDate.Date) { return $true }
        }
        return $false
    }

    # Compute initial candidate date using existing weekend rule
    $today = Get-Date
    switch ($today.DayOfWeek) {
        'Friday'  { $candidate = $today.AddDays(3) }  # Friday -> Monday
        'Saturday'{ $candidate = $today.AddDays(2) }  # Saturday -> Monday
        default   { $candidate = $today.AddDays(1) }  # otherwise -> tomorrow
    }

    # Advance candidate while it's a holiday or weekend
    while ($true) {
        # If candidate is a holiday (including observed), move to next calendar day and re-evaluate
        if (Is-Holiday -CheckDate $candidate) {
            $candidate = $candidate.AddDays(1)
            continue
        }

        # If candidate falls on Saturday or Sunday, jump to Monday
        if ($candidate.DayOfWeek -eq 'Saturday') {
            $candidate = $candidate.AddDays(2)
            continue
        }
        if ($candidate.DayOfWeek -eq 'Sunday') {
            $candidate = $candidate.AddDays(1)
            continue
        }

        # Candidate is not a holiday and not a weekend -> done
        break
    }

    # Final date string used in your automation (avoid naming collision with Date type)
    $DateStr = $candidate.ToString('MM-dd-yyyy')

    # -------------------------
    # Build and send the automation string
    # -------------------------
    $CompileString = "[{Focus,0,Fill *}]" + $DateStr + "[{Wait, 30}][TAB][{Wait, 30}][TAB][{Wait, 30}]12P[{MouseMoveToFocus,100,410}][{MouseButton,L}][{Wait, 30}][t][TAB][{Wait, 10}][ALT+o]"
    & $Clavier /sendkeys $CompileString

} else { exit }
