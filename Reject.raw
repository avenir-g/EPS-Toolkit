<#
{
    "Category": 3,
    "Name": "Out of Stock",
    "Info": "Auto-rejects out-of-stock items during Fill. [Next shipping day at 12 PM] [Use on Fill screen]",
    "Shortcut": "F1",
    "Code": "112",
    "Window": "Minimized",
    "Programs": "java.exe"
}
#>

# Set the working directory to the script's location
$scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
Set-Location -Path $scriptDir

# Load variables from precheck.ps1
. .\precheck.ps1

# Check the exit code of the last command
if ($LASTEXITCODE -ne 0) {
    . .\errorHandler.ps1 $global:precheckError
    exit 1
}

# List of variables to check
$variables = @{
    "Main"     = $Main
    "Clavier"  = $Clavier
    "Cap2Txt"  = $Cap2Txt
    "SendKeys" = $SendKeys
    "Printer"  = $Printer
}

# Check if all necessary variables are defined
foreach ($var in $variables.GetEnumerator()) {
    if (-not $var.Value) {
        $errorMessage = "Error: '$($var.Key)' is not defined.`nOpen Setup [Shift + F1]"
        . .\errorHandler.ps1 $errorMessage
        exit 1
    }
}

$ErrorActionPreference = "Stop"
Add-Type -AssemblyName Microsoft.VisualBasic
Add-Type -AssemblyName System.Windows.Forms

# --------------------------------------------------------------------
# DEBUG helper: simple timestamped log
# --------------------------------------------------------------------
function Write-Log {
    param([string]$Msg, [string]$Level = 'INFO')
    $ts = (Get-Date).ToString("HH:mm:ss.fff")
    Write-Host "[$ts] [$Level] $Msg"
}

# --------------------------------------------------------------------
# Escape for Clavier tag parameters (inside [{Focus...}] / [{FocusOrLaunch...}])
# --------------------------------------------------------------------
function Escape-ClavierParam {
    param([string]$s)
    if ($null -eq $s) { return '' }
    $s = $s -replace '\\', '\\\\'
    $s = $s -replace '\[',  '\\['
    $s = $s -replace '\]',  '\\]'
    $s = $s -replace '\{',  '\\{'
    $s = $s -replace '\}',  '\\}'
    $s = $s -replace ',',   '\\,'
    return $s
}

# --------------------------------------------------------------------
# Dynamic wait for Fill/Reject using Clavier+ only (no clipboard)
# [{FocusOrLaunch,window,command,delay}] : if window exists -> focus; else run command
# --------------------------------------------------------------------
function Wait-WindowViaClavierFS {
    param(
        [string[]]$TitlePatterns,        # e.g., @('Fill *','Reject*')
        [int]$TimeoutSec = 10,
        [int]$PollMs = 200,
        [int]$NudgeEvery = 0,            # gentler: no nudges during wait
        [switch]$VerboseLog
    )

    $marker   = Join-Path $env:TEMP ("clavier_probe_" + [guid]::NewGuid().ToString("N") + ".flag")
    $deadline = (Get-Date).AddSeconds($TimeoutSec)
    $attempt  = 0

    if (Test-Path $marker) { Remove-Item -Force -ErrorAction SilentlyContinue $marker }

    Write-Log "Dynamic wait started. Timeout=${TimeoutSec}s; Poll=${PollMs}ms; Patterns: $($TitlePatterns -join ' | ')" "DEBUG"

    while ((Get-Date) -lt $deadline) {
        foreach ($rawPat in $TitlePatterns) {
            $attempt++
            $pat = Escape-ClavierParam $rawPat

            # Hidden, no-flash marker creation: PowerShell hidden window
            $cmd = "powershell.exe -NoProfile -WindowStyle Hidden -Command ""Set-Content -Path '$marker' -Value 'MISS' -NoNewline -Force"""

            $seq = "[{FocusOrLaunch,$pat,$cmd,0}]"
            Write-Log "Attempt #${attempt}: Clavier /sendkeys $seq" "DEBUG"

            & $Clavier /sendkeys $seq
            Start-Sleep -Milliseconds $PollMs

            if (Test-Path $marker) {
                Remove-Item -Force -ErrorAction SilentlyContinue $marker | Out-Null
                Write-Log "Attempt #${attempt}: '$rawPat' not found (marker created)" "DEBUG"

                if ($NudgeEvery -gt 0 -and ($attempt % $NudgeEvery -eq 0)) {
                    $nudgeSeq = "[{Focus,0,$pat}]"
                    Write-Log "Attempt #${attempt}: Nudge -> Clavier /sendkeys $nudgeSeq" "DEBUG"
                    & $Clavier /sendkeys $nudgeSeq
                }
            }
            else {
                Write-Log "SUCCESS: '$rawPat' activated by Clavier." "INFO"
                return $true
            }
        }
    }

    Write-Log "TIMEOUT: No Fill/Reject match within ${TimeoutSec}s." "WARN"
    return $false
}

# --------------------------------------------------------------------
# Focus Enterprise & request Fill/Reject (Alt+J)
# --------------------------------------------------------------------
[Microsoft.VisualBasic.Interaction]::AppActivate("Enterprise") | Out-Null
[System.Windows.Forms.SendKeys]::SendWait('%{j}')
Write-Log "Sent Alt+J to open Fill/Reject." "DEBUG"

# --------------------------------------------------------------------
# Dynamic wait via Clavier (no clipboard; with terminal logging)
# --------------------------------------------------------------------
$ok = Wait-WindowViaClavierFS -TitlePatterns @('Fill *','Reject*') -TimeoutSec 10 -PollMs 200 -NudgeEvery 0

if (-not $ok) {
    . .\errorHandler.ps1 "Fill/Reject window not detected within 10s after Alt+J. No actions were sent."
    exit 1
}

# Slightly longer settle (gentler)
Start-Sleep -Milliseconds 350
Write-Log "Fill/Reject detected and focused; continuing…" "INFO"

# --------------------------------------------------------------------
# IMPORTANT: restore your “pre-focus kick” (this was the line you missed)
# Run it once here to align the Fill UI state before continuing.
# --------------------------------------------------------------------
& $Clavier /sendkeys "[{Focus,0,Fill *}][Enter][Tab]"
Start-Sleep -Milliseconds 150
Write-Log "Pre-focus kick sent ([Enter][Tab] on Fill)." "DEBUG"

# --------------------------------------------------------------------
# Holiday and scheduling logic (unchanged)
# --------------------------------------------------------------------
function Get-NthWeekdayOfMonth {
    param(
        [int]$Year,
        [int]$Month,
        [System.DayOfWeek]$Weekday,
        [int]$N
    )
    $firstOfMonth = Get-Date -Year $Year -Month $Month -Day 1
    $offset = ([int]$Weekday - [int]$firstOfMonth.DayOfWeek + 7) % 7
    return $firstOfMonth.AddDays($offset + 7*($N-1)).Date
}

function Get-LastWeekdayOfMonth {
    param(
        [int]$Year,
        [int]$Month,
        [System.DayOfWeek]$Weekday
    )
    $lastOfMonth = (Get-Date -Year $Year -Month $Month -Day 1).AddMonths(1).AddDays(-1)
    $offset = ([int]$lastOfMonth.DayOfWeek - [int]$Weekday + 7) % 7
    return $lastOfMonth.AddDays(-$offset).Date
}

function Get-ObservedDate {
    param([datetime]$DateToObserve)
    switch ($DateToObserve.DayOfWeek) {
        'Saturday' { return $DateToObserve.AddDays(-1).Date }  # observed Friday
        'Sunday'   { return $DateToObserve.AddDays(1).Date }   # observed Monday
        default    { return $DateToObserve.Date }
    }
}

function Get-HolidaysForYear {
    param([int]$Year)
    $holidays = @()

    $ny = Get-Date -Year $Year -Month 1 -Day 1
    $holidays += $ny.Date
    $holidays += Get-ObservedDate -DateToObserve $ny

    $presidents = Get-NthWeekdayOfMonth -Year $Year -Month 2 -Weekday ([DayOfWeek]::Monday) -N 3
    $holidays += $presidents

    $memorial = Get-LastWeekdayOfMonth -Year $Year -Month 5 -Weekday ([DayOfWeek]::Monday)
    $holidays += $memorial

    $july4 = Get-Date -Year $Year -Month 7 -Day 4
    $holidays += $july4.Date
    $holidays += Get-ObservedDate -DateToObserve $july4

    $labor = Get-NthWeekdayOfMonth -Year $Year -Month 9 -Weekday ([DayOfWeek]::Monday) -N 1
    $holidays += $labor

    $thanksgiving = Get-NthWeekdayOfMonth -Year $Year -Month 11 -Weekday ([DayOfWeek]::Thursday) -N 4
    $holidays += $thanksgiving

    $xmas = Get-Date -Year $Year -Month 12 -Day 25
    $holidays += $xmas.Date
    $holidays += Get-ObservedDate -DateToObserve $xmas

    return ($holidays | Sort-Object -Unique)
}

function Is-Holiday {
    param([datetime]$CheckDate)
    $yearInt  = [int]$CheckDate.Year
    $prevYear = $yearInt - 1
    $nextYear = $yearInt + 1
    $yearsToCheck = @($prevYear, $yearInt, $nextYear)

    foreach ($y in $yearsToCheck) {
        $hols = Get-HolidaysForYear -Year $y
        if ($hols -contains $CheckDate.Date) { return $true }
    }
    return $false
}

# Compute initial candidate date using existing weekend rule
$today = Get-Date
switch ($today.DayOfWeek) {
    'Friday'   { $candidate = $today.AddDays(3) }  # Friday -> Monday
    'Saturday' { $candidate = $today.AddDays(2) }  # Saturday -> Monday
    default    { $candidate = $today.AddDays(1) }  # otherwise -> tomorrow
}

# Advance candidate while it's a holiday or weekend
while ($true) {
    if (Is-Holiday -CheckDate $candidate) {
        $candidate = $candidate.AddDays(1)
        continue
    }
    if ($candidate.DayOfWeek -eq 'Saturday') {
        $candidate = $candidate.AddDays(2)
        continue
    }
    if ($candidate.DayOfWeek -eq 'Sunday') {
        $candidate = $candidate.AddDays(1)
        continue
    }
    break
}

# Final date string used in your automation
$DateStr = $candidate.ToString('MM-dd-yyyy')
Write-Log "Next ship date resolved to $DateStr" "DEBUG"

# --------------------------------------------------------------------
# Build and send the automation string (your original)
# --------------------------------------------------------------------
$CompileString = "[{Focus,0,Fill *}]" + $DateStr + "[{Wait, 30}][TAB][{Wait, 30}][TAB][{Wait, 30}]12P[{MouseMoveToFocus,100,410}][{MouseButton,L}][{Wait, 30}][t][TAB][{Wait, 10}][ALT+o]"
Write-Log "Sending Clavier sequence…" "DEBUG"
& $Clavier /sendkeys $CompileString
Write-Log "Sequence sent." "INFO"
