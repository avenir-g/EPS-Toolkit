$src = @"
[DllImport("Kernel32.dll")]
public static extern IntPtr GetConsoleWindow();
[DllImport("User32.dll")]
public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
"@
Add-Type -Name ConsoleUtils -Namespace Native -MemberDefinition $src
$consoleHandle = [Native.ConsoleUtils]::GetConsoleWindow()
[Native.ConsoleUtils]::ShowWindow($consoleHandle, 0)

# Set execution policy to Bypass for the current user
Write-Host "Setting execution policy to Bypass for the current user..." -ForegroundColor Cyan
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force

# Add Windows Forms assembly
Write-Host "Adding Windows Forms assembly..." -ForegroundColor Cyan
Add-Type -AssemblyName System.Windows.Forms

# Create a Folder Browser Dialog
Write-Host "Creating Folder Browser Dialog..." -ForegroundColor Cyan
$folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog
$folderBrowser.Description = "Select Installation Directory. The [EPS Toolkit] folder will be created within the selected directory."
$folderBrowser.ShowNewFolderButton = $true
$folderBrowser.SelectedPath = [System.Environment]::GetFolderPath('Desktop')

# Show the dialog and get the result
$result = $folderBrowser.ShowDialog()
if ($result -eq [System.Windows.Forms.DialogResult]::OK) {
    $targetDir = Join-Path -Path $folderBrowser.SelectedPath -ChildPath "EPS_Toolkit"
    Write-Host "Installation directory selected: " -ForegroundColor Green -NoNewline
    Write-Host "$targetDir" -ForegroundColor White
} else {
    Write-Host "Installation cancelled by user." -ForegroundColor Yellow
    exit
}

# Check if target directory exists
if (Test-Path -Path $targetDir) {
    $overwritePrompt = [System.Windows.Forms.MessageBox]::Show("The folder 'EPS Toolkit' already exists. Do you want to close any running programs/scripts and remove and overwrite it?", "Folder Exists", [System.Windows.Forms.MessageBoxButtons]::YesNo, [System.Windows.Forms.MessageBoxIcon]::Warning)
    if ($overwritePrompt -eq [System.Windows.Forms.DialogResult]::Yes) {
        # Close any running programs/scripts within the target directory
        $processes = Get-Process | Where-Object { $_.Path -like "$targetDir\*" -or $_.Name -eq "Clavier" -or $_.Name -eq "Capture2Text" }
        foreach ($process in $processes) {
            Stop-Process -Id $process.Id -Force
            Write-Host "Closed process: $($process.Name)" -ForegroundColor Red
        }

        # Check for multiple instances of Clavier in the startup folder and remove them
        $startupFolder = [System.Environment]::GetFolderPath('Startup')
        $clavierShortcuts = Get-ChildItem -Path $startupFolder -Filter "Clavier*.lnk"
        if ($clavierShortcuts.Count -gt 1) {
            foreach ($shortcut in $clavierShortcuts) {
            Remove-Item -Path $shortcut.FullName -Force
            Write-Host "Removed duplicate Clavier shortcut: $($shortcut.Name)" -ForegroundColor Red
            }
        }
        
        Remove-Item -Path $targetDir -Recurse -Force
        New-Item -ItemType Directory -Path $targetDir -Force
        Write-Host "Existing directory removed and new directory created." -ForegroundColor Green
    } else {
        Write-Host "Installation cancelled by user." -ForegroundColor Yellow
        exit
    }
} else {
    New-Item -ItemType Directory -Path $targetDir -Force
    Write-Host "New directory created: " -ForegroundColor Green -NoNewline
    Write-Host "$targetDir" -ForegroundColor White
}

$src = @"
[DllImport("Kernel32.dll")]
public static extern IntPtr GetConsoleWindow();
[DllImport("User32.dll")]
public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
"@
Add-Type -Name ConsoleUtils -Namespace Native -MemberDefinition $src
$consoleHandle = [Native.ConsoleUtils]::GetConsoleWindow()
[Native.ConsoleUtils]::ShowWindow($consoleHandle, 5)

# Change folder icon to a gear
Write-Host "Changing folder icon to a gear..." -ForegroundColor Cyan
$desktopIniPath = Join-Path -Path $targetDir -ChildPath "desktop.ini"
$osVersion = [System.Environment]::OSVersion.Version
if ($osVersion.Major -eq 10 -and $osVersion.Build -lt 22000) {
    $iconIndex = 316  # Windows 10
} else {
    $iconIndex = 314  # Windows 11
}
$iconPath = "C:\Windows\System32\shell32.dll,$iconIndex"
$desktopIniContent = @"
[.ShellClassInfo]
IconResource=$iconPath
"@
$desktopIniContent | Out-File -FilePath $desktopIniPath -Encoding UTF8
Write-Host "Folder icon set to gear." -ForegroundColor Green

# Set the system and hidden attributes for desktop.ini
Write-Host "Setting system and hidden attributes for desktop.ini..." -ForegroundColor Cyan
Set-ItemProperty -Path $desktopIniPath -Name Attributes -Value ([System.IO.FileAttributes]::System -bor [System.IO.FileAttributes]::Hidden)
Write-Host "Attributes set for desktop.ini." -ForegroundColor Green

# Set the system attribute for the target directory
Write-Host "Setting system attribute for target directory..." -ForegroundColor Cyan
Set-ItemProperty -Path $targetDir -Name Attributes -Value ([System.IO.FileAttributes]::System)
Write-Host "System attribute set for target directory." -ForegroundColor Green

# Unpack the archive
Write-Host "Unpacking the archive..." -ForegroundColor Cyan
$scriptDir = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
$archivePath = Join-Path -Path $scriptDir -ChildPath "Toolkit.zip"
Expand-Archive -Path $archivePath -DestinationPath $targetDir -Force
Write-Host "Archive unpacked to: " -ForegroundColor Green -NoNewline
Write-Host "$targetDir" -ForegroundColor White

# Define the source and destination paths for Capture2Text.ini
$sourceIniPath = Join-Path -Path $targetDir -ChildPath "Capture2Text\Capture2Text.ini"
$destinationFolder = Join-Path -Path $env:APPDATA -ChildPath "Capture2Text"
$destinationIniPath = Join-Path -Path $destinationFolder -ChildPath "Capture2Text.ini"

# Check if the destination folder exists, if not, create it
if (-not (Test-Path -Path $destinationFolder)) {
    New-Item -ItemType Directory -Path $destinationFolder -Force
    Write-Host "Created destination folder: " -ForegroundColor Green -NoNewline
    Write-Host "$destinationFolder" -ForegroundColor White
}

# Copy the Capture2Text.ini file to the destination folder, replacing any existing file
Write-Host "Copying Capture2Text.ini to: " -ForegroundColor Green -NoNewline
Write-Host "$destinationIniPath" -ForegroundColor White
Copy-Item -Path $sourceIniPath -Destination $destinationIniPath -Force

# Generate settings.ini in the main folder
Write-Host "Generating settings.ini..." -ForegroundColor Cyan
$mainSettingsPath = Join-Path -Path $targetDir -ChildPath "settings.ini"
$networkPath = "\\" + (Split-Path -Path $targetDir -Qualifier) + "\Pharmnet"
$mainSettingsContent = @"
[Settings]
Main=$targetDir\
Clavier+=$targetDir\Clavier\Clavier.exe
Cap2Txt=$targetDir\Capture2Text\Capture2Text.exe
Printer=$networkPath
"@
$mainSettingsContent | Out-File -FilePath $mainSettingsPath -Encoding UTF8
Write-Host "Generated settings.ini." -ForegroundColor Green

# Generate Clavier.ini for Clavier
Write-Host "Generating Clavier.ini..." -ForegroundColor Cyan
$clavierSettingsPath = Join-Path -Path $targetDir -ChildPath "Clavier\Clavier.ini"
$clavierSettingsContent = @"
Language=English
Size=637,439,0,1
Columns=77,32,15,10
Sorting=1

Shortcut=Esc
Code=27
Text=[Esc][[powershell.exe Stop-Process -Name "powershell"]]
Usages=0
-
Shortcut=Shift + Delete
Code=1070
Command="$targetDir\Auto_Delete.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=F1
Code=112
Command="$targetDir\Reject.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=Shift + F1
Code=1136
Command="$targetDir\Help.ps1"
Window=Minimized
Usages=0
-
Shortcut=F2
Code=113
Command="$targetDir\Auto_Counsel.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=Shift + F2
Code=1137
Command="$targetDir\Auto_Counsel_Admin.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=F3
Code=114
Command="$targetDir\Auto_CII_Print.ps1"
Window=Minimized
Usages=0
-
Shortcut=F4
Code=115
Command="$targetDir\Quick_Text.ps1"
Window=Normal
Programs=java.exe
Usages=0
-
Shortcut=Shift + F5
Code=1140
Command="$targetDir\Auto_Refill_Denial.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=Shift + F6
Code=1141
Command="$targetDir\Auto_Refill_Request.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=Shift + F7
Code=1142
Command="$targetDir\Auto_Cycle_Count.ps1"
Window=Minimized
Programs=java.exe
Usages=0
-
Shortcut=Shift + F8
Code=1143
Command="$targetDir\Transfers.ps1"
Window=Normal
Programs=java.exe
Usages=0
-
Shortcut=Ctrl + `
Code=704
Command="$targetDir\Kill.ps1"
Window=Minimized
Usages=0
-
Shortcut=Ctrl Right + Shift Right + \
Code=100663516
DistinguishLeftRight=1
CapsLock=No
Text=[{Focus,0,Enterprise Pharmacy System}][{MouseMoveToFocus,100,93}][][{MouseButton,L}][{MouseMoveToFocus,50,146}][][{MouseButton,L}][]USER[TAB][]PASSWORD[ENTER]
Usages=0
"@
$clavierSettingsContent | Out-File -FilePath $clavierSettingsPath -Encoding UTF8
Write-Host "Generated Clavier.ini." -ForegroundColor Green

# Define the path to Clavier executable
$clavierExePath = Join-Path -Path $targetDir -ChildPath "Clavier\Clavier.exe"

# Create a shortcut to Clavier in the startup folder
Write-Host "Creating Clavier shortcut in startup folder..." -ForegroundColor Cyan
$WScriptShell = New-Object -ComObject WScript.Shell
$startupFolder = [System.Environment]::GetFolderPath('Startup')
$shortcutPath = Join-Path -Path $startupFolder -ChildPath "Clavier.lnk"
$shortcut = $WScriptShell.CreateShortcut($shortcutPath)
$shortcut.TargetPath = $clavierExePath
$shortcut.WorkingDirectory = $targetDir
$shortcut.IconLocation = $clavierExePath
$shortcut.Save()
Write-Host "Clavier shortcut created." -ForegroundColor Green

# Define the GitHub repository and target directory
$repoOwner = "avenir-g"
$repoName = "EPS-Toolkit"
$personalAccessToken = "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"
$repoUrl = "https://github.com/$repoOwner/$repoName"
$commitHashesFile = Join-Path -Path $targetDir -ChildPath "commit_hashes.json"

# Function to get the latest commit hash for a file
function Get-LatestCommitHash {
    param (
        [string]$filePath
    )
    $apiUrl = "https://api.github.com/repos/$repoOwner/$repoName/commits?path=$filePath"
    $headers = @{
        'Authorization' = "token $personalAccessToken"
        'User-Agent' = 'PowerShell'
    }
    $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers
    return $response[0].sha
}

# Function to get all .raw files from the repository
function Get-RawFiles {
    $apiUrl = "https://api.github.com/repos/$repoOwner/$repoName/contents"
    $headers = @{
        'Authorization' = "token $personalAccessToken"
        'User-Agent' = 'PowerShell'
    }
    $response = Invoke-RestMethod -Uri $apiUrl -Headers $headers
    return $response | Where-Object { $_.name -like "*.raw" }
}

# Initialize commit hashes as an empty hashtable
$commitHashes = @{}

# Get the list of .raw files from the repository
$scripts = Get-RawFiles

# Download scripts
foreach ($script in $scripts) {
    $scriptName = $script.name
    $latestHash = Get-LatestCommitHash -filePath $scriptName
    if ($commitHashes[$scriptName] -ne $latestHash) {
        Write-Host "Downloading " -ForegroundColor Green -NoNewline
        Write-Host "$scriptName" -ForegroundColor Yellow
        # Download the updated script
        $scriptUrl = "$repoUrl/raw/main/$scriptName"
        $scriptPath = Join-Path -Path $targetDir -ChildPath $scriptName
        Invoke-WebRequest -Uri $scriptUrl -OutFile $scriptPath -ErrorAction Stop

        # Convert .raw to .ps1
        $ps1Path = [System.IO.Path]::ChangeExtension($scriptPath, ".ps1")
        if (Test-Path -Path $ps1Path) {
            Remove-Item -Path $ps1Path -Force
        }
        Rename-Item -Path $scriptPath -NewName $ps1Path

        # Update the commit hash
        $commitHashes[$scriptName] = $latestHash
    }
}

# Ensure the commit hashes file path is correctly set
$commitHashesFile = Join-Path -Path $targetDir -ChildPath "commit_hashes.json"

# Save updated commit hashes
$commitHashes | ConvertTo-Json | Set-Content -Path $commitHashesFile
Write-Host "Commit hashes updated." -ForegroundColor Green

# Generate the update script
Write-Host "Generating Update.ps1..." -ForegroundColor Cyan
$updateScriptPath = Join-Path -Path $targetDir -ChildPath "Update.ps1"
$updateScriptContent = @"
<#
{
    "Category": 3,
    "Name": "Update",
    "Shortcut": "N/A",
    "Info": "Check for updates and download files from the Github EPS-Toolkit repository."
}
#>

`$targetDir = '$targetDir'
# Define the GitHub repository and target directory
`$repoOwner = '$repoOwner'
`$repoName = '$repoName'
`$personalAccessToken = '$personalAccessToken'
`$repoUrl = "https://github.com/`$repoOwner/`$repoName"
`$commitHashesFile = Join-Path -Path `$targetDir -ChildPath 'commit_hashes.json'

# Function to get the latest commit hash for a file
function Get-LatestCommitHash {
    param (
        [string]`$filePath
    )
    `$apiUrl = "https://api.github.com/repos/`$repoOwner/`$repoName/commits?path=`$filePath"
    `$headers = @{
        'Authorization' = "token `$personalAccessToken"
        'User-Agent' = 'PowerShell'
    }
    `$response = Invoke-RestMethod -Uri `$apiUrl -Headers `$headers
    return `$response[0].sha
}

# Function to get all .raw files from the repository
function Get-RawFiles {
    `$apiUrl = "https://api.github.com/repos/`$repoOwner/`$repoName/contents"
    `$headers = @{
        'Authorization' = "token `$personalAccessToken"
        'User-Agent' = 'PowerShell'
    }
    `$response = Invoke-RestMethod -Uri `$apiUrl -Headers `$headers
    return `$response | Where-Object { `$_.name -like "*.raw" }
}

# Function to download a file from the repository
function Download-File {
    param (
        [string]`$filePath,
        [string]`$destinationPath
    )
    `$apiUrl = "https://api.github.com/repos/`$repoOwner/`$repoName/contents/`$filePath"
    `$headers = @{
        'Authorization' = "token `$personalAccessToken"
        'User-Agent' = 'PowerShell'
    }
    `$response = Invoke-RestMethod -Uri `$apiUrl -Headers `$headers
    `$content = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(`$response.content))
    Set-Content -Path `$destinationPath -Value `$content -Force
}

# Load existing commit hashes
if (Test-Path -Path `$commitHashesFile) {
    `$commitHashes = Get-Content -Path `$commitHashesFile | ConvertFrom-Json
} else {
    `$commitHashes = @{}
}

# Get the list of .raw files from the repository
`$scripts = Get-RawFiles

# Temporary dictionary to store updated commit hashes
`$updatedCommitHashes = @{}
# Array to store the names of files that need to be updated
`$filesToUpdate = @()

# Check for updates and compare commit hashes
foreach (`$script in `$scripts) {
    `$scriptName = `$script.name
    `$latestHash = Get-LatestCommitHash -filePath `$scriptName
    `$oldHash = if (`$commitHashes.PSObject.Properties[`$scriptName]) { `$commitHashes.PSObject.Properties[`$scriptName].Value } else { `$null }
    if (`$oldHash -ne `$latestHash) {
        
        # Add the script name to the array of files to update
        `$filesToUpdate += `$scriptName
        
        # Update the commit hash in the temporary dictionary
        `$updatedCommitHashes[`$scriptName] = `$latestHash
    } else {
        # Keep the old hash if no update is needed
        `$updatedCommitHashes[`$scriptName] = `$oldHash
    }
}

# Check if there are any files to update
if (`$filesToUpdate.Count -eq 1) {
    Write-Host "Update available for `$(`$filesToUpdate.Count) File..." -ForegroundColor Cyan
} elseif (`$filesToUpdate.Count -gt 1) {
    Write-Host "Update available for `$(`$filesToUpdate.Count) Files..." -ForegroundColor Cyan
} else {
}

# Download updated files
foreach (`$scriptName in `$filesToUpdate) {
    Write-Host "Downloading " -ForegroundColor Green -NoNewline
    Write-Host `$scriptName -ForegroundColor White
    
    # Download the updated file
    `$scriptPath = Join-Path -Path `$targetDir -ChildPath `$scriptName
    Download-File -filePath `$scriptName -destinationPath `$scriptPath
    
    # Convert .raw to .ps1
    `$ps1Path = [System.IO.Path]::ChangeExtension(`$scriptPath, ".ps1")
    if (Test-Path -Path `$ps1Path) {
        Remove-Item -Path `$ps1Path -Force
    }
    Rename-Item -Path `$scriptPath -NewName `$ps1Path
}

# Save the updated commit hashes to the file
`$updatedCommitHashes | ConvertTo-Json | Set-Content -Path `$commitHashesFile -Force

# Check if there are any files to update
if (`$filesToUpdate.Count -eq 1) {
    Write-Host "Done! Updated `$(`$filesToUpdate.Count) File!"
    . ./successHandler.ps1 "Done! Updated `$(`$filesToUpdate.Count) File!"
    exit
} elseif (`$filesToUpdate.Count -gt 1) {
    Write-Host "Done! Updated `$(`$filesToUpdate.Count) Files!"
    . ./successHandler.ps1 "Done! Updated `$(`$filesToUpdate.Count) Files!"
    exit
} else {
    . ./successHandler.ps1 "No updates found!"
    exit
}
"@

$updateScriptContent | Out-File -FilePath $updateScriptPath -Encoding UTF8
Write-Host "Update.ps1 created." -ForegroundColor Green

# Remove previous .ps1 file associations
Write-Host "Deleting previous .ps1 associations..." -ForegroundColor Cyan
Remove-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\.ps1" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "Registry::HKEY_CURRENT_USER\Software\Classes\.ps1" -Recurse -Force -ErrorAction SilentlyContinue
Write-Host "Previous .ps1 associations deleted." -ForegroundColor Green

# Create the registry key for .ps1 files under HKCU
Write-Host "Establishing .ps1 registry key..." -ForegroundColor Cyan
New-Item -Path "Registry::HKEY_CURRENT_USER\Software\Classes\.ps1" -Force
Write-Host ".ps1 registry key established." -ForegroundColor Green

# Set the default value for the .ps1 key to 'Microsoft.PowerShellScript.1'
Write-Host "Setting default value for .ps1 key..." -ForegroundColor Cyan
Set-ItemProperty -Path "Registry::HKEY_CURRENT_USER\Software\Classes\.ps1" -Name "(Default)" -Value "Microsoft.PowerShellScript.1"
Write-Host "Default value set for .ps1 key." -ForegroundColor Green

# Ensure the Microsoft.PowerShellScript.1 association exists
Write-Host "Ensuring 'Microsoft.PowerShellScript.1' registry key exists..." -ForegroundColor Cyan
New-Item -Path "Registry::HKEY_CURRENT_USER\Software\Classes\Microsoft.PowerShellScript.1" -Force
Write-Host "'Microsoft.PowerShellScript.1' registry key ensured." -ForegroundColor Green

# Set the default value for the 'Microsoft.PowerShellScript.1' key to specify PowerShell execution
Write-Host "Setting default value for 'Microsoft.PowerShellScript.1' key..." -ForegroundColor Cyan
Set-ItemProperty -Path "Registry::HKEY_CURRENT_USER\Software\Classes\Microsoft.PowerShellScript.1" -Name "(Default)" -Value "Windows PowerShell Script"
Write-Host "Default value set for 'Microsoft.PowerShellScript.1' key." -ForegroundColor Green

# Set the command to execute .ps1 files with PowerShell
Write-Host "Setting command to execute .ps1 files with PowerShell..." -ForegroundColor Cyan
New-Item -Path "Registry::HKEY_CURRENT_USER\Software\Classes\Microsoft.PowerShellScript.1\shell\open\command" -Force
Set-ItemProperty -Path "Registry::HKEY_CURRENT_USER\Software\Classes\Microsoft.PowerShellScript.1\shell\open\command" -Name "(Default)" -Value "`"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe`" -File `"%1`""
Write-Host "Command set to execute .ps1 files with PowerShell." -ForegroundColor Green


# Launch Clavier
Write-Host "Starting Clavier..." -ForegroundColor Cyan
$clavierExePath = Join-Path -Path $targetDir -ChildPath "Clavier\Clavier.exe"
Start-Process -FilePath $clavierExePath -WindowStyle Minimized
Write-Host "Clavier started!" -ForegroundColor Green

# Launch Help.ps1
Write-Host "Starting Help.ps1..." -ForegroundColor Cyan
$helpScriptPath = Join-Path -Path $targetDir -ChildPath "Help.ps1"
Start-Process -FilePath "powershell.exe" -ArgumentList "-ExecutionPolicy Bypass -File `"$helpScriptPath`"" -WindowStyle Hidden
Write-Host "Help.ps1 started!" -ForegroundColor Green

# Restart Explorer
Write-Host "Restarting Explorer..." -ForegroundColor Cyan
Stop-Process -Name explorer -Force
Write-Host "Installation finished!" -ForegroundColor Green
Start-Sleep -Seconds 15
exit